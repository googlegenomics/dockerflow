/*
 * Copyright 2016 Google.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *      http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.google.cloud.genomics.dockerflow.task;

import com.google.cloud.genomics.dockerflow.DockerflowConstants;
import com.google.cloud.genomics.dockerflow.util.StringUtils;
import java.io.IOException;
import java.io.Serializable;
import java.util.ArrayList;
import java.util.Comparator;
import java.util.LinkedHashMap;
import java.util.LinkedHashSet;
import java.util.List;
import java.util.Map;
import java.util.Set;
import javax.script.ScriptException;

/**
 * A replacement for the autogenerated Pipelines API's Pipeline object. Reason: it works with
 * standard json serializers. Added copy constructor and parameter substitution.
 */
@SuppressWarnings("serial")
public class TaskDefn implements Serializable {
  private String name;
  private String description;
  private String projectId;
  private String pipelineId;
  private Set<Param> inputParameters;
  private Set<Param> outputParameters;
  private Resources resources;
  private Docker docker;

  /** Copy constructor. */
  public TaskDefn(TaskDefn defn) {
    if (defn != null) {
      name = defn.name;
      description = defn.description;
      projectId = defn.projectId;
      pipelineId = defn.pipelineId;
      if (defn.getInputParameters() != null) {
        inputParameters = new LinkedHashSet<Param>(defn.getInputParameters().size());
        for (Param p : defn.getInputParameters()) {
          inputParameters.add(new Param(p));
        }
      }
      if (defn.getOutputParameters() != null) {
        outputParameters = new LinkedHashSet<Param>(defn.getOutputParameters().size());
        for (Param p : defn.getOutputParameters()) {
          outputParameters.add(new Param(p));
        }
      }
      if (defn.getResources() != null) {
        resources = new Resources(defn.getResources());
      }
      if (defn.getDocker() != null) {
        docker = new Docker(defn.getDocker());
      }
    }
  }

  public TaskDefn() {}

  public String getName() {
    return name;
  }

  /**
   * The name of the task. Only letters, numbers, and underscores are allowed.
   *
   * @param name
   */
  public void setName(String name) {
    if (name != null && !name.matches("^\\w+$")) {
      throw new IllegalArgumentException(
          "Task name can only contain word characters: \"" + name + "\"");
    }
    this.name = name;
  }

  public String getDescription() {
    return description;
  }

  public void setDescription(String description) {
    this.description = description;
  }

  public String getProjectId() {
    return projectId;
  }

  public void setProjectId(String projectId) {
    this.projectId = projectId;
  }

  public String getPipelineId() {
    return pipelineId;
  }

  public void setPipelineId(String pipelineId) {
    this.pipelineId = pipelineId;
  }

  public Set<Param> getInputParameters() {
    return inputParameters;
  }

  public Param getParam(String name) {
    if (name == null) {
      return null;
    }
    if (inputParameters != null) {
      for (Param p : inputParameters) {
        if (name.equals(p.getName())) {
          return p;
        }
      }
    }
    if (outputParameters != null) {
      for (Param p : outputParameters) {
        if (name.equals(p.getName())) {
          return p;
        }
      }
    }
    return null;
  }

  public boolean hasParam(String name) {
    return getParam(name) != null;
  }

  /** Non-null, possibly empty list of all input and output parameters. */
  public Set<Param> getParams() {
    Set<Param> retval = new LinkedHashSet<Param>();
    if (inputParameters != null) {
      retval.addAll(inputParameters);
    }
    if (outputParameters != null) {
      retval.addAll(outputParameters);
    }
    return retval;
  }

  public Param getInput(String name) {
    if (inputParameters == null || name == null) {
      return null;
    }
    for (Param p : inputParameters) {
      if (name.equals(p.getName())) {
        return p;
      }
    }
    return null;
  }

  public void setInputParameters(Set<Param> inputParameters) {
    this.inputParameters = inputParameters;
  }

  public Set<Param> getOutputParameters() {
    return outputParameters;
  }

  public Param getOutput(String name) {
    if (outputParameters == null || name == null) {
      return null;
    }
    for (Param p : outputParameters) {
      if (name.equals(p.getName())) {
        return p;
      }
    }
    return null;
  }

  public void setOutputParameters(Set<Param> outputParameters) {
    this.outputParameters = outputParameters;
  }

  public Resources getResources() {
    return resources;
  }

  public void setResources(Resources resources) {
    this.resources = resources;
  }

  public Docker getDocker() {
    return docker;
  }

  public void setDocker(Docker docker) {
    this.docker = docker;
  }

  /**
   * Resources.
   */
  public static class Resources implements Serializable {
    private String bootDiskSizeGb;
    private String minimumCpuCores;
    private String minimumRamGb;
    private Boolean preemptible;
    private List<String> zones;
    private List<Disk> disks;

    public Resources(Resources resources) {
      if (resources != null) {
        bootDiskSizeGb = resources.bootDiskSizeGb;
        minimumCpuCores = resources.minimumCpuCores;
        minimumRamGb = resources.minimumRamGb;
        preemptible = resources.preemptible;
        if (resources.getZones() != null) {
          zones = new ArrayList<String>(resources.getZones());
        }
        if (resources.getDisks() != null) {
          disks = new ArrayList<Disk>();
          for (Disk d : resources.getDisks()) {
            disks.add(new Disk(d));
          }
        }
      }
    }

    public Resources() {}

    public String getBootDiskSizeGb() {
      return bootDiskSizeGb;
    }

    public void setBootDiskSizeGb(String bootDiskSizeGb) {
      this.bootDiskSizeGb = bootDiskSizeGb;
    }

    public String getMinimumCpuCores() {
      return minimumCpuCores;
    }

    public void setMinimumCpuCores(String minCpuCores) {
      this.minimumCpuCores = minCpuCores;
    }

    public String getMinimumRamGb() {
      return minimumRamGb;
    }

    public void setMinimumRamGb(String memory) {
      this.minimumRamGb = memory;
    }

    public Boolean getPreemptible() {
      return preemptible;
    }

    public void setPreemptible(Boolean preemptible) {
      this.preemptible = preemptible;
    }

    public List<String> getZones() {
      return zones;
    }

    public void setZones(List<String> zones) {
      this.zones = zones;
    }

    public List<Disk> getDisks() {
      return disks;
    }

    public void setDisks(List<Disk> disks) {
      this.disks = disks;
    }

    public void applyGlobals(Map<String, String> globals) {
      minimumCpuCores = StringUtils.replaceAll(globals, minimumCpuCores);
      minimumRamGb = StringUtils.replaceAll(globals, minimumRamGb);

      if (disks != null) {
        for (Disk d : disks) {
          d.setSizeGb(StringUtils.replaceAll(globals, d.getSizeGb()));
        }
      }
    }

    public void evalJavaScript() throws ScriptException {
      if (StringUtils.isJavaScript(minimumCpuCores)) {
        minimumCpuCores = StringUtils.evalJavaScript(minimumCpuCores);
      }
      if (StringUtils.isJavaScript(minimumRamGb)) {
        minimumRamGb = StringUtils.evalJavaScript(minimumRamGb);
      }
      if (disks != null) {
        for (Disk d : disks) {
          if (StringUtils.isJavaScript(d.getSizeGb())) {
            d.setSizeGb(StringUtils.evalJavaScript(d.getSizeGb()));
          }
        }
      }
    }
  }

  /**
   * Docker image and command.
   */
  public static class Docker implements Serializable {
    private String imageName;
    private String cmd;

    public Docker(Docker docker) {
      imageName = docker.imageName;
      cmd = docker.cmd;
    }

    public Docker() {}

    public String getImageName() {
      return imageName;
    }

    public void setImageName(String imageName) {
      this.imageName = imageName;
    }

    public String getCmd() {
      return cmd;
    }

    public void setCmd(String cmd) {
      this.cmd = cmd;
    }
  }

  /**
   * Disk.
   */
  public static class Disk implements Serializable {
    private String name;
    private String type;
    private String mountPoint;
    private String sizeGb;
    private Boolean readOnly;
    private Boolean autoDelete;
    private String source;

    public Disk(Disk d) {
      if (d != null) {
        name = d.name;
        type = d.type;
        mountPoint = d.mountPoint;
        sizeGb = d.sizeGb;
        readOnly = d.readOnly;
        autoDelete = d.autoDelete;
        source = d.source;
      }
    }

    public Disk() {}

    public static Disk defaultDisk() {
      Disk d = new Disk();
      d.type = DockerflowConstants.DEFAULT_DISK_TYPE;
      d.name = DockerflowConstants.DEFAULT_DISK_NAME;
      d.mountPoint = DockerflowConstants.DEFAULT_MOUNT_POINT;
      return d;
    }

    public String getName() {
      return name;
    }

    public void setName(String name) {
      this.name = name;
    }

    public String getType() {
      return type;
    }

    public void setType(String type) {
      this.type = type;
    }

    public String getMountPoint() {
      return mountPoint;
    }

    public void setMountPoint(String mountPoint) {
      this.mountPoint = mountPoint;
    }

    public String getSizeGb() {
      return sizeGb;
    }

    public void setSizeGb(String sizeGb) {
      this.sizeGb = sizeGb;
    }

    public Boolean getReadOnly() {
      return readOnly;
    }

    public void setReadOnly(Boolean readOnly) {
      this.readOnly = readOnly;
    }

    public Boolean getAutoDelete() {
      return autoDelete;
    }

    public void setAutoDelete(Boolean autoDelete) {
      this.autoDelete = autoDelete;
    }

    public String getSource() {
      return source;
    }

    public void setSource(String source) {
      this.source = source;
    }
  }

  /**
   * Task parameters.
   */
  public static class Param implements Serializable {
    public static final String TYPE_ARRAY = "array";
    public static final String ARRAY_DELIMITER_REGEX = "\\s+";
    public static final String TYPE_FILE = "file";
    public static final String TYPE_FOLDER = "folder";

    private String name;
    private String description;
    private String type;
    private String defaultValue;
    private LocalCopy localCopy;
    private InputBinding inputBinding;

    public Param(Param p) {
      name = p.name;
      description = p.description;
      type = p.type;
      defaultValue = p.defaultValue;
      if (p.localCopy != null) {
        localCopy = new LocalCopy(p.localCopy);
      }
      if (p.inputBinding != null) {
        inputBinding = new InputBinding(p.inputBinding);
      }
    }

    public Param() {}

    /** Split an array value from json or delimited. */
    public String[] split(String value) {
      String[] array;

      // Array may be json, like ["val1","val2"]
      if (value.trim().startsWith("[") && value.trim().endsWith("]")) {
        try {
          array = StringUtils.fromJson(value, String[].class);
        } catch (IOException e) {
          throw new IllegalStateException(
              "Invalid json array for parameter \"" + name + "\": " + value);
        }
      // If not, assume it's a delimited list
      } else {
        array = value.replace("\\n", " ").split(ARRAY_DELIMITER_REGEX);
      }
      return array;
    }

    /**
     * Apply the input binding to format the string, doing things like adding delimiters.
     *
     * @param value
     * @return
     */
    public String bindValue(String value) {
      String retval;

      // Nothing to do
      if (inputBinding == null) {
        retval = value;
      }
      // Boolean value
      else if (type != null && "boolean".equalsIgnoreCase(type)) {
        retval = inputBinding.getPrefix();
      } else if (type == null || value == null) {
        retval = value;
      // Other CWL stuff
      } else {
        StringBuilder sb = new StringBuilder();

        if (inputBinding.getPrefix() != null) {
          sb.append(inputBinding.getPrefix());
        }

        // Arrays
        if ("array".equalsIgnoreCase(type) || type.endsWith("[]")) {
          String[] array = split(value);

          // Not a file array
          if (localCopy == null) {
            boolean isFirst = true;

            for (String s : array) {
              if (s.trim().length() > 0) {
                if (!isFirst && inputBinding.getItemSeparator() != null) {
                  sb.append(inputBinding.getItemSeparator());
                }
                sb.append(s);
                isFirst = false;
              }
            }
          }
        // All other parameters
        } else {
          sb.append(value);
        }
        retval = sb.toString();
      }
      return retval;
    }

    public String getName() {
      return name;
    }

    public void setName(String name) {
      this.name = name;
    }

    public String getDescription() {
      return description;
    }

    public void setDescription(String description) {
      this.description = description;
    }

    public String getDefaultValue() {
      return defaultValue;
    }

    public void setDefaultValue(String defaultValue) {
      this.defaultValue = defaultValue;
    }

    public boolean isFile() {
      return (type == null && localCopy != null) || 
          (type != null && type.toLowerCase().startsWith(TYPE_FILE));
    }

    public boolean isFolder() {
      return type != null && type.toLowerCase().startsWith(TYPE_FOLDER);
    }

    public LocalCopy getLocalCopy() {
      return localCopy;
    }

    public void setLocalCopy(LocalCopy localCopy) {
      this.localCopy = localCopy;
    }

    public InputBinding getInputBinding() {
      return inputBinding;
    }

    public void setInputBinding(InputBinding binding) {
      this.inputBinding = binding;
    }

    public boolean isArray() {
      return (type != null && (type.equalsIgnoreCase(TYPE_ARRAY) || type.endsWith("[]")));
    }

    public String getType() {
      return type;
    }

    public void setType(String type) {
      this.type = type;
    }
  }

  /**
   * Sort by position in the command-line.
   */
  public static class ParamComparator implements Comparator<Param> {

    @Override
    public int compare(Param o1, Param o2) {
      Integer pos1 =
          (o1.getInputBinding() != null && o1.getInputBinding().getPosition() != null)
              ? o1.getInputBinding().getPosition()
              : -1;
      Integer pos2 =
          (o2.getInputBinding() != null && o2.getInputBinding().getPosition() != null)
              ? o2.getInputBinding().getPosition()
              : -1;

      return pos1 == pos2 ? o1.getName().compareTo(o2.getName()) : pos1.compareTo(pos2);
    }
  }

  /** For CWL support. */
  public static class InputBinding implements Serializable {
    private String prefix;
    private String itemSeparator;
    private Integer position;

    public InputBinding() {}

    public InputBinding(InputBinding binding) {
      if (binding != null) {
        prefix = binding.prefix;
        itemSeparator = binding.itemSeparator;
        position = binding.position;
      }
    }

    public String getPrefix() {
      return prefix;
    }

    public void setPrefix(String prefix) {
      this.prefix = prefix;
    }

    public String getItemSeparator() {
      return itemSeparator;
    }

    public void setItemSeparator(String itemSeparator) {
      this.itemSeparator = itemSeparator;
    }

    public Integer getPosition() {
      return position;
    }

    public void setPosition(Integer position) {
      this.position = position;
    }
  }

  /**
   * For file staging.
   */
  public static class LocalCopy implements Serializable {
    private String disk;
    private String path;

    public LocalCopy(LocalCopy localCopy) {
      disk = localCopy.disk;
      path = localCopy.path;
    }

    public LocalCopy() {}

    public String getDisk() {
      return disk;
    }

    public void setDisk(String disk) {
      this.disk = disk;
    }

    public String getPath() {
      return path;
    }

    public void setPath(String path) {
      this.path = path;
    }
  }

  /**
   * Replace variables within the defaultValue of input and output parameters.
   *
   * @param variables
   */
  public void substitute(Map<String, String> variables) {
    String prefix = name + ".";
    Map<String, String> superset = new LinkedHashMap<String, String>();
    if (variables != null) {
      superset.putAll(variables);
    }

    // Allow referencing of local variables without a prefix like
    // taskName.inputName.
    if (variables != null) {
      for (String k : variables.keySet()) {
        String key = k.startsWith(prefix) ? k.substring(prefix.length()) : k;
        String val = variables.get(k);
        superset.put(key, val);
      }
    }

    if (inputParameters != null) {
      for (Param p : inputParameters) {
        String def = p.getDefaultValue();
        def = StringUtils.replaceAll(superset, def);
        p.setDefaultValue(def);

        if ((p.isFile() || p.isFolder()) && p.getLocalCopy() != null) {
          String val = p.getLocalCopy().getPath();
          p.getLocalCopy().setPath(StringUtils.replaceAll(superset, val));
        }
      }
    }

    if (outputParameters != null) {
      for (Param p : outputParameters) {
        String def = p.getDefaultValue();
        def = StringUtils.replaceAll(superset, def);
        p.setDefaultValue(def);

        if (p.getLocalCopy() != null) {
          String val = p.getLocalCopy().getPath();
          p.getLocalCopy().setPath(StringUtils.replaceAll(superset, val));
        }
      }
    }

    if (resources != null) {
      resources.applyGlobals(superset);
    }
  }
}
